{"ast":null,"code":"// Google Places API Service for fetching address images\n// You'll need to set REACT_APP_GOOGLE_API_KEY in your .env file\n\nconst GOOGLE_API_KEY = process.env.REACT_APP_GOOGLE_API_KEY;\nclass GooglePlacesService {\n  // Get Google Street View image for a specific address\n  static async getStreetViewImage(address, size = '400x250') {\n    if (!GOOGLE_API_KEY) {\n      console.warn('Google API key not found. Please set REACT_APP_GOOGLE_API_KEY in your .env file');\n      return null;\n    }\n    try {\n      const encodedAddress = encodeURIComponent(address);\n      const url = `https://maps.googleapis.com/maps/api/streetview?size=${size}&location=${encodedAddress}&key=${GOOGLE_API_KEY}`;\n\n      // Test if the URL is accessible\n      const response = await fetch(url);\n      if (response.ok) {\n        return url;\n      }\n      return null;\n    } catch (error) {\n      console.error('Error fetching Street View image:', error);\n      return null;\n    }\n  }\n\n  // Get Google Places photo for a specific address\n  static async getPlacePhoto(address, maxWidth = 400) {\n    if (!GOOGLE_API_KEY) {\n      console.warn('Google API key not found. Please set REACT_APP_GOOGLE_API_KEY in your .env file');\n      return null;\n    }\n    try {\n      const encodedAddress = encodeURIComponent(address);\n\n      // First, find the place\n      const findPlaceUrl = `https://maps.googleapis.com/maps/api/place/findplacefromtext/json?input=${encodedAddress}&inputtype=textquery&fields=place_id,photos&key=${GOOGLE_API_KEY}`;\n      const findResponse = await fetch(findPlaceUrl);\n      const findData = await findResponse.json();\n      if (findData.status === 'OK' && findData.candidates && findData.candidates[0].photos) {\n        const photoReference = findData.candidates[0].photos[0].photo_reference;\n        const photoUrl = `https://maps.googleapis.com/maps/api/place/photo?maxwidth=${maxWidth}&photoreference=${photoReference}&key=${GOOGLE_API_KEY}`;\n        return photoUrl;\n      }\n      return null;\n    } catch (error) {\n      console.error('Error fetching Place photo:', error);\n      return null;\n    }\n  }\n\n  // Get the best available image for an address (Street View first, then Places photo)\n  static async getBestAddressImage(address, size = '400x250') {\n    try {\n      // Try Street View first (most accurate for addresses)\n      let imageUrl = await this.getStreetViewImage(address, size);\n      if (!imageUrl) {\n        // Fallback to Places photo\n        imageUrl = await this.getPlacePhoto(address, parseInt(size.split('x')[0]));\n      }\n      return imageUrl;\n    } catch (error) {\n      console.error('Error getting best address image:', error);\n      return null;\n    }\n  }\n\n  // Get multiple images for comparison (address1 vs address2)\n  static async getComparisonImages(address1, address2) {\n    try {\n      const [image1, image2] = await Promise.all([this.getBestAddressImage(address1), this.getBestAddressImage(address2)]);\n      return {\n        image1,\n        image2\n      };\n    } catch (error) {\n      console.error('Error getting comparison images:', error);\n      return {\n        image1: null,\n        image2: null\n      };\n    }\n  }\n}\nexport default GooglePlacesService;","map":{"version":3,"names":["GOOGLE_API_KEY","process","env","REACT_APP_GOOGLE_API_KEY","GooglePlacesService","getStreetViewImage","address","size","console","warn","encodedAddress","encodeURIComponent","url","response","fetch","ok","error","getPlacePhoto","maxWidth","findPlaceUrl","findResponse","findData","json","status","candidates","photos","photoReference","photo_reference","photoUrl","getBestAddressImage","imageUrl","parseInt","split","getComparisonImages","address1","address2","image1","image2","Promise","all"],"sources":["C:/Users/mandy/Downloads/fyp-app/fyp-app/frontend/src/services/googlePlaces.js"],"sourcesContent":["// Google Places API Service for fetching address images\n// You'll need to set REACT_APP_GOOGLE_API_KEY in your .env file\n\nconst GOOGLE_API_KEY = process.env.REACT_APP_GOOGLE_API_KEY;\n\nclass GooglePlacesService {\n  // Get Google Street View image for a specific address\n  static async getStreetViewImage(address, size = '400x250') {\n    if (!GOOGLE_API_KEY) {\n      console.warn('Google API key not found. Please set REACT_APP_GOOGLE_API_KEY in your .env file');\n      return null;\n    }\n\n    try {\n      const encodedAddress = encodeURIComponent(address);\n      const url = `https://maps.googleapis.com/maps/api/streetview?size=${size}&location=${encodedAddress}&key=${GOOGLE_API_KEY}`;\n      \n      // Test if the URL is accessible\n      const response = await fetch(url);\n      if (response.ok) {\n        return url;\n      }\n      return null;\n    } catch (error) {\n      console.error('Error fetching Street View image:', error);\n      return null;\n    }\n  }\n\n  // Get Google Places photo for a specific address\n  static async getPlacePhoto(address, maxWidth = 400) {\n    if (!GOOGLE_API_KEY) {\n      console.warn('Google API key not found. Please set REACT_APP_GOOGLE_API_KEY in your .env file');\n      return null;\n    }\n\n    try {\n      const encodedAddress = encodeURIComponent(address);\n      \n      // First, find the place\n      const findPlaceUrl = `https://maps.googleapis.com/maps/api/place/findplacefromtext/json?input=${encodedAddress}&inputtype=textquery&fields=place_id,photos&key=${GOOGLE_API_KEY}`;\n      \n      const findResponse = await fetch(findPlaceUrl);\n      const findData = await findResponse.json();\n      \n      if (findData.status === 'OK' && findData.candidates && findData.candidates[0].photos) {\n        const photoReference = findData.candidates[0].photos[0].photo_reference;\n        const photoUrl = `https://maps.googleapis.com/maps/api/place/photo?maxwidth=${maxWidth}&photoreference=${photoReference}&key=${GOOGLE_API_KEY}`;\n        return photoUrl;\n      }\n      \n      return null;\n    } catch (error) {\n      console.error('Error fetching Place photo:', error);\n      return null;\n    }\n  }\n\n  // Get the best available image for an address (Street View first, then Places photo)\n  static async getBestAddressImage(address, size = '400x250') {\n    try {\n      // Try Street View first (most accurate for addresses)\n      let imageUrl = await this.getStreetViewImage(address, size);\n      \n      if (!imageUrl) {\n        // Fallback to Places photo\n        imageUrl = await this.getPlacePhoto(address, parseInt(size.split('x')[0]));\n      }\n      \n      return imageUrl;\n    } catch (error) {\n      console.error('Error getting best address image:', error);\n      return null;\n    }\n  }\n\n  // Get multiple images for comparison (address1 vs address2)\n  static async getComparisonImages(address1, address2) {\n    try {\n      const [image1, image2] = await Promise.all([\n        this.getBestAddressImage(address1),\n        this.getBestAddressImage(address2)\n      ]);\n      \n      return { image1, image2 };\n    } catch (error) {\n      console.error('Error getting comparison images:', error);\n      return { image1: null, image2: null };\n    }\n  }\n}\n\nexport default GooglePlacesService;\n"],"mappings":"AAAA;AACA;;AAEA,MAAMA,cAAc,GAAGC,OAAO,CAACC,GAAG,CAACC,wBAAwB;AAE3D,MAAMC,mBAAmB,CAAC;EACxB;EACA,aAAaC,kBAAkBA,CAACC,OAAO,EAAEC,IAAI,GAAG,SAAS,EAAE;IACzD,IAAI,CAACP,cAAc,EAAE;MACnBQ,OAAO,CAACC,IAAI,CAAC,iFAAiF,CAAC;MAC/F,OAAO,IAAI;IACb;IAEA,IAAI;MACF,MAAMC,cAAc,GAAGC,kBAAkB,CAACL,OAAO,CAAC;MAClD,MAAMM,GAAG,GAAG,wDAAwDL,IAAI,aAAaG,cAAc,QAAQV,cAAc,EAAE;;MAE3H;MACA,MAAMa,QAAQ,GAAG,MAAMC,KAAK,CAACF,GAAG,CAAC;MACjC,IAAIC,QAAQ,CAACE,EAAE,EAAE;QACf,OAAOH,GAAG;MACZ;MACA,OAAO,IAAI;IACb,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdR,OAAO,CAACQ,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;MACzD,OAAO,IAAI;IACb;EACF;;EAEA;EACA,aAAaC,aAAaA,CAACX,OAAO,EAAEY,QAAQ,GAAG,GAAG,EAAE;IAClD,IAAI,CAAClB,cAAc,EAAE;MACnBQ,OAAO,CAACC,IAAI,CAAC,iFAAiF,CAAC;MAC/F,OAAO,IAAI;IACb;IAEA,IAAI;MACF,MAAMC,cAAc,GAAGC,kBAAkB,CAACL,OAAO,CAAC;;MAElD;MACA,MAAMa,YAAY,GAAG,2EAA2ET,cAAc,mDAAmDV,cAAc,EAAE;MAEjL,MAAMoB,YAAY,GAAG,MAAMN,KAAK,CAACK,YAAY,CAAC;MAC9C,MAAME,QAAQ,GAAG,MAAMD,YAAY,CAACE,IAAI,CAAC,CAAC;MAE1C,IAAID,QAAQ,CAACE,MAAM,KAAK,IAAI,IAAIF,QAAQ,CAACG,UAAU,IAAIH,QAAQ,CAACG,UAAU,CAAC,CAAC,CAAC,CAACC,MAAM,EAAE;QACpF,MAAMC,cAAc,GAAGL,QAAQ,CAACG,UAAU,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC,CAAC,CAACE,eAAe;QACvE,MAAMC,QAAQ,GAAG,6DAA6DV,QAAQ,mBAAmBQ,cAAc,QAAQ1B,cAAc,EAAE;QAC/I,OAAO4B,QAAQ;MACjB;MAEA,OAAO,IAAI;IACb,CAAC,CAAC,OAAOZ,KAAK,EAAE;MACdR,OAAO,CAACQ,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;MACnD,OAAO,IAAI;IACb;EACF;;EAEA;EACA,aAAaa,mBAAmBA,CAACvB,OAAO,EAAEC,IAAI,GAAG,SAAS,EAAE;IAC1D,IAAI;MACF;MACA,IAAIuB,QAAQ,GAAG,MAAM,IAAI,CAACzB,kBAAkB,CAACC,OAAO,EAAEC,IAAI,CAAC;MAE3D,IAAI,CAACuB,QAAQ,EAAE;QACb;QACAA,QAAQ,GAAG,MAAM,IAAI,CAACb,aAAa,CAACX,OAAO,EAAEyB,QAAQ,CAACxB,IAAI,CAACyB,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAC5E;MAEA,OAAOF,QAAQ;IACjB,CAAC,CAAC,OAAOd,KAAK,EAAE;MACdR,OAAO,CAACQ,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;MACzD,OAAO,IAAI;IACb;EACF;;EAEA;EACA,aAAaiB,mBAAmBA,CAACC,QAAQ,EAAEC,QAAQ,EAAE;IACnD,IAAI;MACF,MAAM,CAACC,MAAM,EAAEC,MAAM,CAAC,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CACzC,IAAI,CAACV,mBAAmB,CAACK,QAAQ,CAAC,EAClC,IAAI,CAACL,mBAAmB,CAACM,QAAQ,CAAC,CACnC,CAAC;MAEF,OAAO;QAAEC,MAAM;QAAEC;MAAO,CAAC;IAC3B,CAAC,CAAC,OAAOrB,KAAK,EAAE;MACdR,OAAO,CAACQ,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;MACxD,OAAO;QAAEoB,MAAM,EAAE,IAAI;QAAEC,MAAM,EAAE;MAAK,CAAC;IACvC;EACF;AACF;AAEA,eAAejC,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}